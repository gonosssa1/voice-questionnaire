<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI-Validated Insurance Questionnaire</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root {
      --brand-primary: #46199B;
      --brand-secondary: #7757C1;
      --brand-highlight: #C5B8DF;
      --brand-background: #F7F7F7;
      --brand-text: #111111;
      --brand-text-secondary: #737271;
      --brand-border: #A0A0A0;
    }
    body {
      font-family: "FSAlbertW05-Bold", "Open Sans", Helvetica, Arial, sans-serif;
    }
    @keyframes pulse-ring {
      0% { transform: scale(0.95); opacity: 1; }
      50% { transform: scale(1.05); opacity: 0.7; }
      100% { transform: scale(0.95); opacity: 1; }
    }
    .pulse-ring { animation: pulse-ring 1.5s ease-in-out infinite; }
    
    @keyframes sound-wave {
      0%, 100% { height: 8px; }
      50% { height: 24px; }
    }
    .sound-bar { animation: sound-wave 0.5s ease-in-out infinite; }
    .sound-bar:nth-child(2) { animation-delay: 0.1s; }
    .sound-bar:nth-child(3) { animation-delay: 0.2s; }
    .sound-bar:nth-child(4) { animation-delay: 0.3s; }
    .sound-bar:nth-child(5) { animation-delay: 0.4s; }
  </style>
</head>
<body class="min-h-screen bg-[var(--brand-background)] text-[var(--brand-text)] font-sans">

  <div id="app"></div>

  <script>
    // ============================================================================
    // SERVER CONFIGURATION (loaded from backend)
    // ============================================================================
    
    let serverConfig = {
      ttsEnabled: false,
      validationEnabled: false,
      validationProvider: 'anthropic',
    };

    // Load config from server
    async function loadConfig() {
      try {
        const response = await fetch('/api/config');
        serverConfig = await response.json();
        console.log('Server config loaded:', serverConfig);
      } catch (error) {
        console.error('Failed to load server config:', error);
      }
    }

    // ============================================================================
    // QUESTION SCRIPT - Exactly what will be asked, in exact order
    // ============================================================================
    
    const QUESTIONS = [
      {
        id: 'cust_id_first_name',
        section: 'Welcome',
        question: 'Can I have your first name?',
        type: 'open',
      },
      {
        id: 'cust_id_last_name',
        section: 'Welcome',
        question: 'Can I have your last name?',
        type: 'open',
      },
      {
        id: 'pmv.has_primary_provider',
        section: 'Primary Medical Provider',
        question: 'Do you have a primary medical provider?',
        type: 'yes_no',
      },
      {
        id: 'pmv.last_visit_reason',
        section: 'Primary Medical Provider',
        question: 'What was the reason for your last visit or consultation with your primary medical provider?',
        type: 'open',
        requires: { id: 'pmv.has_primary_provider', answer: 'YES' },
        followups: {
          max: 5,
          when: 'after_valid',
          topic: 'primary care visit details',
          guidance: 'Focus on cause, diagnosis, or treatment. Do not ask about tests, labs, imaging, or results unless the user explicitly mentioned them.',
          stopOnNoResponse: true,
        },
      },
      {
        id: 'pmv.last_visit_date',
        section: 'Primary Medical Provider',
        question: 'When was this visit?',
        type: 'date',
        requires: { id: 'pmv.has_primary_provider', answer: 'YES' },
      },
      {
        id: 'pmv.last_visit_results',
        section: 'Primary Medical Provider',
        question: 'What were the results?',
        type: 'open',
        requires: { id: 'pmv.has_primary_provider', answer: 'YES' },
        followups: {
          max: 5,
          when: 'after_valid',
          topic: 'visit results and outcomes',
          guidance: 'Ask about outcome, diagnosis, treatment changes, or doctor summary. Avoid lab values unless tests were mentioned.',
          stopOnNoResponse: true,
        },
      },
      {
        id: 'pmv.last_visit_treatment',
        section: 'Primary Medical Provider',
        question: 'What treatment or medications were prescribed?',
        type: 'open',
        requires: { id: 'pmv.has_primary_provider', answer: 'YES' },
        followups: {
          max: 5,
          when: 'after_valid',
          topic: 'treatment and medications',
          guidance: 'Ask about dosages, adherence, treatment changes, or side effects. If unclear, confirm the treatment or medication is for the stated condition. Avoid re-asking for medication names.',
          stopOnNoResponse: true,
        },
      },
      {
        id: 'pmv.last_visit_provider_name',
        section: 'Primary Medical Provider',
        question: 'Do you know the name of the medical provider you saw for this checkup?',
        type: 'open',
        requires: { id: 'pmv.has_primary_provider', answer: 'YES' },
      },
      {
        id: 'cardio.gateway',
        section: 'Cardiovascular',
        question: 'Do you have any disorder or disease of the heart, blood vessels, or circulatory system (including high blood pressure/high cholesterol)?',
        type: 'yes_no',
        onNo: 'END',
      },
      {
        id: 'cardio.dx',
        section: 'Cardiovascular',
        question: 'What diagnoses apply? (hypertension, hyperlipidemia, CAD, arrhythmia)',
        type: 'open',
        requires: { id: 'cardio.gateway', answer: 'YES' },
      },
      {
        id: 'cardio.dx_date',
        section: 'Cardiovascular',
        question: 'When was the condition diagnosed?',
        type: 'date',
        requires: { id: 'cardio.gateway', answer: 'YES' },
      },
      {
        id: 'cardio.bp_known',
        section: 'Cardiovascular',
        question: 'Do you know your most recent blood pressure reading?',
        type: 'yes_no',
        requires: {
          all: [{ id: 'cardio.gateway', answer: 'YES' }],
          any: [
            { id: 'cardio.dx', contains: 'hypertension' },
            { id: 'cardio.dx', contains: 'high blood pressure' },
          ],
        },
      },
      {
        id: 'cardio.bp_sys',
        section: 'Cardiovascular',
        question: 'Most recent systolic blood pressure (top number)?',
        type: 'number',
        requires: { id: 'cardio.bp_known', answer: 'YES' },
      },
      {
        id: 'cardio.bp_dia',
        section: 'Cardiovascular',
        question: 'Most recent diastolic blood pressure (bottom number)?',
        type: 'number',
        requires: { id: 'cardio.bp_known', answer: 'YES' },
      },
      {
        id: 'cardio.control_duration',
        section: 'Cardiovascular',
        question: 'How long have readings been controlled at roughly the current level?',
        type: 'open',
        requires: {
          all: [{ id: 'cardio.bp_known', answer: 'YES' }],
          any: [
            { id: 'cardio.dx', contains: 'hypertension' },
            { id: 'cardio.dx', contains: 'high blood pressure' },
          ],
        },
      },
      {
        id: 'cardio.on_meds',
        section: 'Cardiovascular',
        question: 'Are you taking medication for this condition?',
        type: 'yes_no',
        requires: { id: 'cardio.gateway', answer: 'YES' },
        followups: {
          max: 5,
          when: 'after_valid',
          topic: 'cardiovascular medications',
          guidance: 'Ask about medication names, dosage, or adherence. If unclear, confirm the medication is for the stated condition. Avoid labs unless tests were mentioned.',
          stopOnNoResponse: true,
        },
      },
      {
        id: 'cardio.provider_name',
        section: 'Cardiovascular',
        question: 'Do you know the name of the medical provider you saw for this condition?',
        type: 'open',
        requires: { id: 'cardio.gateway', answer: 'YES' },
      }
    ];
    const DEFAULT_LANGUAGE = 'en';
    const LANGUAGE_OPTIONS = {
      en: { label: 'English', asrLang: 'en-US', ttsLang: 'en-US', htmlLang: 'en' },
      es: { label: 'Español', asrLang: 'es-ES', ttsLang: 'es-ES', htmlLang: 'es' },
    };

    const UI_STRINGS = {
      en: {
        title: 'AI-Validated Insurance Questionnaire',
        headerSubtitle: 'AI Voice Application Prototype',
        headerTitle: 'Medical History Questionnaire',
        headerTagline: 'Insurance Application',
        progressLabel: 'Progress',
        questionCount: (current, total) => `Question ${current} of ${total}`,
        readyTitle: 'Ready to Begin',
        readyDescription: 'This questionnaire will ask about your medical history using voice interaction. Please ensure you are in a quiet environment and speak clearly.',
        startButton: 'Start Application',
        unsupportedAsr: 'Voice recognition is not supported in this browser. Please use Chrome or Edge.',
        speakingLabel: 'Speaking',
        speakingSub: 'Please listen to the question',
        listeningLabel: 'Listening',
        listeningSub: 'Please speak your answer clearly',
        validatingLabel: 'Processing',
        validatingSub: 'Analyzing your response with AI',
        yesNoHint: 'Please answer yes or no',
        optionsLabel: 'Options',
        retryLabel: (current, total) => `Attempt ${current} of ${total}`,
        endCallButton: 'End Call',
        completionTitle: 'Application Complete',
        completionDescription: 'Thank you for completing the questionnaire. Your responses have been recorded.',
        summaryTitle: 'Response Summary',
        summaryEmpty: 'No responses recorded',
        followupLabel: (index) => `Follow-up ${index}:`,
        restartButton: 'Start New Application',
        handoffTitle: 'Agent Handoff Requested',
        handoffDescription: 'We can connect you with an agent to finish this question.',
        handoffRestartButton: 'Start Over',
        chatAssistantName: 'Underwriting Assistant',
        chatSubtitle: 'Live demo transcript',
        chatEmpty: 'Conversation will appear here.',
        voiceModeEnabled: 'Voice mode enabled',
        transcriptLabel: (count) => `Transcript (${count})`,
        transcriptUser: 'User',
        transcriptSystem: 'System',
        languageLabel: 'Language',
        introMessage: 'Hello and Thank you for choosing Protective Life. During this phone call I will ask several questions regarding your lifestyle and health. This information will help us with your life insurance application.',
        completionMessage: 'Thank you for choosing Protective Life. Your responses have been recorded.',
        whyFallback: 'This helps us understand your medical history for your application.',
        medicalConditionsAnnouncement: 'Now we will go through some specific medical conditions. Please let me know if you have had any of the conditions so that we can obtain additional information where necessary.',
        noResponseRetry: "I didn't hear anything. Let me repeat the question.",
        noResponseMoveOn: "I'm having trouble hearing you. Let's move on.",
        repeatAcknowledgement: "Sure, I'll repeat the question.",
        thankYou: 'Thank you.',
        whyPrompt: 'Let me know if you want me to repeat it, or go ahead and answer.',
        handoffPrompt: 'I want to make sure we get this right. I can connect you to an agent, or we can move forward here. What do you prefer?',
        moveOnNext: "Let's move on to the next question.",
        retryEscalation: " Let's try once more.",
        bridgeOptions: [
          "That's why we ask.",
          'I appreciate you asking.',
          'Thanks for checking on that.',
          'That context helps.',
        ],
        genericExplanation: {
          yes_no: 'Please answer with a clear yes or no.',
          date: 'Please provide a date.',
          number: 'Please provide a number.',
          choice: 'Please choose one of the options.',
          open: 'Please provide a valid response.',
        },
      },
      es: {
        title: 'Cuestionario de seguro validado por IA',
        headerSubtitle: 'Prototipo de aplicación de voz con inteligencia artificial',
        headerTitle: 'Cuestionario de historial médico',
        headerTagline: 'Solicitud de seguro',
        progressLabel: 'Progreso',
        questionCount: (current, total) => `Pregunta ${current} de ${total}`,
        readyTitle: 'Listo para comenzar',
        readyDescription: 'Este cuestionario le hará preguntas sobre su historial médico mediante interacción por voz. Por favor, asegúrese de estar en un entorno tranquilo y hable con claridad.',
        startButton: 'Iniciar aplicación',
        unsupportedAsr: 'El reconocimiento de voz no es compatible con este navegador. Use Chrome o Edge.',
        speakingLabel: 'Hablando',
        speakingSub: 'Por favor, escuche la pregunta.',
        listeningLabel: 'Escuchando',
        listeningSub: 'Por favor, diga su respuesta con claridad.',
        validatingLabel: 'Procesando',
        validatingSub: 'Analizando su respuesta con IA.',
        yesNoHint: 'Por favor, responda sí o no.',
        optionsLabel: 'Opciones',
        retryLabel: (current, total) => `Intento ${current} de ${total}`,
        endCallButton: 'Finalizar llamada',
        completionTitle: 'Solicitud completada',
        completionDescription: 'Gracias por completar el cuestionario. Sus respuestas han sido registradas.',
        summaryTitle: 'Resumen de respuestas',
        summaryEmpty: 'No hay respuestas registradas',
        followupLabel: (index) => `Seguimiento ${index}:`,
        restartButton: 'Iniciar nueva solicitud',
        handoffTitle: 'Transferencia a agente solicitada',
        handoffDescription: 'Podemos conectarlo con un agente para terminar esta pregunta.',
        handoffRestartButton: 'Comenzar de nuevo',
        chatAssistantName: 'Asistente de suscripción',
        chatSubtitle: 'Transcripción de la demostración en vivo',
        chatEmpty: 'La conversación aparecerá aquí.',
        voiceModeEnabled: 'Modo de voz habilitado',
        transcriptLabel: (count) => `Transcripción (${count})`,
        transcriptUser: 'Usuario',
        transcriptSystem: 'Sistema',
        languageLabel: 'Idioma',
        introMessage: 'Hola y gracias por elegir Protective Life. Durante esta llamada telefónica le haré varias preguntas sobre su estilo de vida y salud. Esta información nos ayudará con su solicitud de seguro de vida.',
        completionMessage: 'Gracias por elegir Protective Life. Sus respuestas han sido registradas.',
        whyFallback: 'Esto nos ayuda a entender su historial médico para su solicitud.',
        medicalConditionsAnnouncement: 'Ahora repasaremos algunas condiciones médicas específicas. Por favor, hágame saber si ha tenido alguna de las condiciones para que podamos obtener información adicional cuando sea necesario.',
        noResponseRetry: 'No escuché nada. Permítame repetir la pregunta.',
        noResponseMoveOn: 'Estoy teniendo problemas para escucharle. Sigamos adelante.',
        repeatAcknowledgement: 'Claro, repetiré la pregunta.',
        thankYou: 'Gracias.',
        whyPrompt: 'Dígame si quiere que la repita o puede responder.',
        handoffPrompt: 'Quiero asegurarme de que lo hagamos bien. Puedo conectarlo con un agente, o podemos continuar aquí. ¿Qué prefiere?',
        moveOnNext: 'Pasemos a la siguiente pregunta.',
        retryEscalation: ' Intentemos una vez más.',
        bridgeOptions: [
          'Por eso lo preguntamos.',
          'Gracias por preguntar.',
          'Gracias por comprobarlo.',
          'Ese contexto ayuda.',
        ],
        genericExplanation: {
          yes_no: 'Por favor, responda con un sí o un no.',
          date: 'Por favor, proporcione una fecha.',
          number: 'Por favor, proporcione un número.',
          choice: 'Por favor, elija una de las opciones.',
          open: 'Por favor, proporcione una respuesta válida.',
        },
      },
    };

    const SECTION_TRANSLATIONS = {
      es: {
        'Welcome': 'Bienvenida',
        'Primary Medical Provider': 'Proveedor médico primario',
        'Cardiovascular': 'Cardiovascular',
      },
    };

    const QUESTION_TRANSLATIONS = {
      es: {
        'cust_id_first_name': '¿Puedo tener su primer nombre?',
        'cust_id_last_name': '¿Puedo tener su apellido?',
        'pmv.has_primary_provider': '¿Tiene un proveedor médico primario?',
        'pmv.last_visit_reason': '¿Cuál fue el motivo de su última visita o consulta con su proveedor médico primario?',
        'pmv.last_visit_date': '¿Cuándo fue esta visita?',
        'pmv.last_visit_results': '¿Cuáles fueron los resultados?',
        'pmv.last_visit_treatment': '¿Qué tratamiento o medicamentos le recetaron?',
        'pmv.last_visit_provider_name': '¿Sabe el nombre del proveedor médico que vio para este chequeo?',
        'cardio.gateway': '¿Tiene algún trastorno o enfermedad del corazón, vasos sanguíneos o sistema circulatorio (incluyendo presión arterial alta/colesterol alto)?',
        'cardio.dx': '¿Qué diagnósticos aplican? (hipertensión, hiperlipidemia, enfermedad arterial coronaria, arritmia)',
        'cardio.dx_date': '¿Cuándo se diagnosticó la condición?',
        'cardio.bp_known': '¿Sabe su lectura de presión arterial más reciente?',
        'cardio.bp_sys': '¿Presión arterial sistólica más reciente (número superior)?',
        'cardio.bp_dia': '¿Presión arterial diastólica más reciente (número inferior)?',
        'cardio.control_duration': '¿Cuánto tiempo han estado controladas las lecturas aproximadamente al nivel actual?',
        'cardio.on_meds': '¿Está tomando medicamento para esta condición?',
        'cardio.provider_name': '¿Sabe el nombre del proveedor médico que vio para esta condición?',
      },
    };

    function normalizeLanguage(lang) {
      return LANGUAGE_OPTIONS[lang] ? lang : DEFAULT_LANGUAGE;
    }

    function getLanguageConfig(lang) {
      return LANGUAGE_OPTIONS[normalizeLanguage(lang)];
    }

    function getStrings(lang) {
      return UI_STRINGS[normalizeLanguage(lang)];
    }

    function getSectionLabel(section, lang) {
      const translations = SECTION_TRANSLATIONS[normalizeLanguage(lang)] || {};
      return translations[section] || section;
    }

    function getQuestionText(question, lang) {
      const translations = QUESTION_TRANSLATIONS[normalizeLanguage(lang)] || {};
      return translations[question.id] || question.question;
    }

    const MAX_RETRIES = 3;
    const MAX_EXPLAINS = 2;

    // ============================================================================
    // TEXT-TO-SPEECH SERVICE
    // ============================================================================
    
    class TTSService {
      constructor(lang = 'en-US') {
        this.audioContext = null;
        this.currentSource = null;
        this.isSpeaking = false;
        this.lang = lang;
      }

      setLanguage(lang) {
        this.lang = lang;
      }

      async speak(text) {
        this.isSpeaking = true;
        
        try {
          if (serverConfig.ttsEnabled) {
            await this.speakElevenLabs(text);
          } else {
            await this.speakWebSpeech(text);
          }
        } finally {
          this.isSpeaking = false;
        }
      }

      async speakElevenLabs(text) {
        try {
          const response = await fetch('/api/tts', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ text, language: this.lang }),
          });

          if (!response.ok) {
            console.error('TTS API error, falling back to Web Speech');
            return this.speakWebSpeech(text);
          }

          const arrayBuffer = await response.arrayBuffer();
          
          if (!this.audioContext) {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          }

          const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
          
          return new Promise((resolve) => {
            const source = this.audioContext.createBufferSource();
            this.currentSource = source;
            source.buffer = audioBuffer;
            source.connect(this.audioContext.destination);
            source.onended = () => {
              this.currentSource = null;
              resolve();
            };
            source.start(0);
          });
        } catch (error) {
          console.error('ElevenLabs error:', error);
          return this.speakWebSpeech(text);
        }
      }

      speakWebSpeech(text) {
        return new Promise((resolve) => {
          window.speechSynthesis.cancel();
          const utterance = new SpeechSynthesisUtterance(text);
          utterance.lang = this.lang;
          utterance.rate = 0.9;
          utterance.pitch = 1;
          utterance.onend = resolve;
          utterance.onerror = () => resolve();
          window.speechSynthesis.speak(utterance);
        });
      }

      stop() {
        this.isSpeaking = false;
        if (this.currentSource) {
          try { this.currentSource.stop(); } catch (e) {}
          this.currentSource = null;
        }
        window.speechSynthesis.cancel();
      }
    }

    // ============================================================================
    // SPEECH RECOGNITION SERVICE
    // ============================================================================
    
    class ASRService {
      constructor(lang = 'en-US') {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        this.recognition = SpeechRecognition ? new SpeechRecognition() : null;
        this.lang = lang;
        
        if (this.recognition) {
          this.recognition.continuous = false;
          this.recognition.interimResults = false;
          this.recognition.lang = this.lang;
          this.recognition.maxAlternatives = 1;
        }
      }

      setLanguage(lang) {
        this.lang = lang;
        if (this.recognition) {
          this.recognition.lang = lang;
        }
      }

      isSupported() {
        return !!this.recognition;
      }

      listen(timeoutMs = 10000) {
        return new Promise((resolve, reject) => {
          if (!this.recognition) {
            reject(new Error('Speech recognition not supported'));
            return;
          }

          let resolved = false;
          let timeoutId = null;

          const cleanup = () => {
            if (timeoutId) clearTimeout(timeoutId);
          };

          this.recognition.onresult = (event) => {
            if (!resolved) {
              resolved = true;
              cleanup();
              resolve(event.results[0][0].transcript);
            }
          };

          this.recognition.onerror = (event) => {
            if (!resolved && event.error !== 'no-speech') {
              resolved = true;
              cleanup();
              reject(new Error(event.error));
            }
          };

          this.recognition.onend = () => {
            if (!resolved) {
              resolved = true;
              cleanup();
              resolve('');
            }
          };

          timeoutId = setTimeout(() => {
            if (!resolved) {
              resolved = true;
              this.recognition.stop();
              cleanup();
              resolve('');
            }
          }, timeoutMs);

          this.recognition.lang = this.lang;
          this.recognition.start();
        });
      }

      stop() {
        if (this.recognition) {
          try { this.recognition.stop(); } catch (e) {}
        }
      }
    }

    // ============================================================================
    // VALIDATION SERVICE (calls backend API)
    // ============================================================================
    
    class ValidationService {
      async validate(question, questionType, transcript, choices = null) {
        try {
          const response = await fetch('/api/validate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ question, questionType, transcript, choices }),
          });

          if (!response.ok) {
            throw new Error('Validation API error');
          }

          return await response.json();
        } catch (error) {
          console.error('Validation error:', error);
          return { valid: false, normalized: null, explanation: null, repeat: false };
        }
      }
    }

    class WhyService {
      async explain(question, section, explainLevel = 1, previousExplanation = null, fallbackExplanation = null) {
        try {
          const response = await fetch('/api/why', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ question, section, explainLevel, previousExplanation }),
          });

          if (!response.ok) {
            throw new Error('Why API error');
          }

          return await response.json();
        } catch (error) {
          console.error('Why explanation error:', error);
          return { explanation: fallbackExplanation || 'This helps us understand your medical history for your application.' };
        }
      }
    }

    class FollowupService {
      async nextQuestion(payload) {
        try {
          const response = await fetch('/api/followup', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });

          if (!response.ok) {
            throw new Error('Followup API error');
          }

          return await response.json();
        } catch (error) {
          console.error('Followup error:', error);
          return { done: true };
        }
      }

      async checkOverlap(payload) {
        try {
          const response = await fetch('/api/followup-check', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });

          if (!response.ok) {
            throw new Error('Followup check API error');
          }

          return await response.json();
        } catch (error) {
          console.error('Followup check error:', error);
          return { allow: true };
        }
      }
    }
    // ============================================================================
    // FLOW CONTROLLER
    // ============================================================================
    
    class FlowController {
      constructor() {
        this.state = {
          status: 'idle',
          currentQuestionIndex: -1,
          answers: {},
          transcript: [],
          retryCount: 0,
          explainCounts: {},
          lastWhyExplanation: null,
          announcementsPlayed: {},
          followups: {},
          pendingAssistantMessage: null,
          error: null,
          language: DEFAULT_LANGUAGE,
        };

        const languageConfig = getLanguageConfig(this.state.language);
        this.tts = new TTSService(languageConfig.ttsLang);
        this.asr = new ASRService(languageConfig.asrLang);
        this.validator = new ValidationService();
        this.why = new WhyService();
        this.followup = new FollowupService();
        this.sessionId = 0;
        
        this.onStateChange = null;

        this.applyLanguage(this.state.language);
      }

      setState(updates) {
        this.state = { ...this.state, ...updates };
        if (this.onStateChange) this.onStateChange(this.state);
      }

      applyLanguage(lang) {
        const normalized = normalizeLanguage(lang);
        const config = getLanguageConfig(normalized);
        this.tts.setLanguage(config.ttsLang);
        this.asr.setLanguage(config.asrLang);
        document.documentElement.lang = config.htmlLang;
        document.title = getStrings(normalized).title;
      }

      setLanguage(lang) {
        const normalized = normalizeLanguage(lang);
        if (this.state.language === normalized) return;
        this.applyLanguage(normalized);
        this.setState({ language: normalized });
      }

      recordUserAnswer(text) {
        this.state.transcript.push({ role: 'user', text });
        this.setState({ status: 'validating' });
      }

      findNextQuestionIndex(fromIndex, answers) {
        for (let i = fromIndex; i < QUESTIONS.length; i++) {
          const q = QUESTIONS[i];
          
          if (q.requires) {
            const requirementGroups = q.requires.all || q.requires.any
              ? {
                  all: Array.isArray(q.requires.all) ? q.requires.all : [],
                  any: Array.isArray(q.requires.any) ? q.requires.any : [],
                }
              : {
                  all: Array.isArray(q.requires) ? q.requires : [q.requires],
                  any: [],
                };

            const matchesRequirement = (req) => {
              const dependentAnswer = answers[req.id];
              if (req.answer && dependentAnswer !== req.answer) return false;
              if (req.contains) {
                const normalized = (dependentAnswer || '').toString().toLowerCase();
                if (!normalized.includes(req.contains.toLowerCase())) return false;
              }
              return true;
            };

            const meetsAll = requirementGroups.all.every(matchesRequirement);
            const meetsAny = requirementGroups.any.length === 0
              ? true
              : requirementGroups.any.some(matchesRequirement);

            if (!meetsAll || !meetsAny) continue;
          }
          
          return i;
        }
        return -1;
      }

      getRecentUserAnswers(limit = 3) {
        const recent = [];
        for (let i = this.state.transcript.length - 1; i >= 0 && recent.length < limit; i -= 1) {
          if (this.state.transcript[i].role === 'user') {
            recent.push(this.state.transcript[i].text);
          }
        }
        return recent.reverse();
      }

      getPreviousFollowupQuestions(questionId) {
        const followups = this.state.followups[questionId];
        if (!followups || !Array.isArray(followups.items)) return [];
        return followups.items.map((item) => item.q);
      }

      getSectionAnswers(section) {
        if (!section) return {};
        const result = {};
        for (const q of QUESTIONS) {
          if (q.section === section && this.state.answers[q.id] !== undefined) {
            result[q.id] = this.state.answers[q.id];
          }
        }
        return result;
      }

      getRecentQuestionAnswerPairs(limit = 4) {
        const pairs = [];
        for (let i = this.state.transcript.length - 1; i >= 0 && pairs.length < limit; i -= 1) {
          if (this.state.transcript[i].role === 'assistant') {
            const questionText = this.state.transcript[i].text;
            let answerText = null;
            for (let j = i + 1; j < this.state.transcript.length; j += 1) {
              if (this.state.transcript[j].role === 'user') {
                answerText = this.state.transcript[j].text;
                break;
              }
            }
            if (answerText) {
              pairs.unshift({ q: questionText, a: answerText });
            }
          }
        }
        return pairs;
      }

      getUpcomingQuestionTexts(fromIndex, limit = 4, language = this.state.language) {
        const upcoming = [];
        for (let i = fromIndex + 1; i < QUESTIONS.length && upcoming.length < limit; i += 1) {
          const nextQuestion = QUESTIONS[i];
          if (nextQuestion && nextQuestion.question) {
            upcoming.push(getQuestionText(nextQuestion, language));
          }
        }
        return upcoming;
      }

      isSimilarToUpcomingQuestion(followupText, upcomingQuestions) {
        if (!followupText || !Array.isArray(upcomingQuestions)) return false;
        const normalize = (text) =>
          text
            .toLowerCase()
            .replace(/[^a-z0-9\s]/g, ' ')
            .split(/\s+/)
            .filter((word) => word.length > 2);
        const followupTokens = new Set(normalize(followupText));
        if (followupTokens.size === 0) return false;

        for (const upcoming of upcomingQuestions) {
          if (!upcoming) continue;
          const upcomingTokens = new Set(normalize(upcoming));
          if (upcomingTokens.size === 0) continue;

          let overlap = 0;
          for (const token of followupTokens) {
            if (upcomingTokens.has(token)) overlap += 1;
          }

          const overlapRatio = overlap / Math.max(1, followupTokens.size);
          if (overlapRatio >= 0.6) return true;
          if (upcoming.toLowerCase().includes(followupText.toLowerCase())) return true;
          if (followupText.toLowerCase().includes(upcoming.toLowerCase())) return true;
        }

        return false;
      }

      handleSkipTo(skipToId, currentIndex, answers) {
        if (skipToId === 'END') return -1;
        
        const targetIndex = QUESTIONS.findIndex(q => q.id === skipToId);
        if (targetIndex !== -1) {
          return this.findNextQuestionIndex(targetIndex, answers);
        }
        return this.findNextQuestionIndex(currentIndex + 1, answers);
      }

      async askQuestion(questionIndex, options = {}) {
        const { preserveRetryCount = false, retryCountOverride = null } = options;
        const sessionId = this.sessionId;
        const strings = getStrings(this.state.language);
        if (questionIndex < 0 || questionIndex >= QUESTIONS.length) {
          this.setState({ status: 'speaking', currentQuestionIndex: -1 });
          await this.speakAssistant(strings.completionMessage, sessionId);
          if (this.sessionId !== sessionId) return;
          this.setState({ status: 'complete' });
          return;
        }

        const shouldResetWhy = questionIndex !== this.state.currentQuestionIndex;
        const shouldResetRetry = questionIndex !== this.state.currentQuestionIndex;
        const question = QUESTIONS[questionIndex];
        const language = this.state.language;
        const questionText = getQuestionText(question, language);
        this.setState({ 
          status: 'speaking', 
          currentQuestionIndex: questionIndex,
          retryCount: retryCountOverride !== null
            ? retryCountOverride
            : (shouldResetRetry ? 0 : this.state.retryCount),
          lastWhyExplanation: shouldResetWhy ? null : this.state.lastWhyExplanation,
        });

        // Announce the Lifestyle and Medical Related questions
        // const Lifestyle_and_Medical_Message = "Next we will be going through some Lifestyle and medical related questions. Please keep in mind that the answers are assumed to be to the best of your knowledge. In order to expedite the overall application process we do like to obtain as much information as possible up front to eliminate any delays.";
        // if (questionIndex === 2) {
        //   this.setState({ showQuestionText: false });
        //   this.state.transcript.push({ role: 'assistant', text: Lifestyle_and_Medical_Message });
        //   await this.tts.speak(Lifestyle_and_Medical_Message);
        // }

        // Announce the Medical Conditions related questions
        const Medical_Conditions_Message = strings.medicalConditionsAnnouncement;
        if (questionIndex === 8 && !this.state.announcementsPlayed.medicalConditions) {
          this.setState({ showQuestionText: false });
          await this.speakAssistant(Medical_Conditions_Message, sessionId);
          this.setState({
            announcementsPlayed: {
              ...this.state.announcementsPlayed,
              medicalConditions: true,
            },
          });
        }

        this.setState({ showQuestionText: true });
        await this.speakAssistant(questionText, sessionId);
        if (this.sessionId !== sessionId) return;

        this.setState({ status: 'listening', pendingAssistantMessage: null });
        
        try {
          const spokenAnswer = await this.asr.listen(15000);
          if (this.sessionId !== sessionId) return;
          
          if (!spokenAnswer) {
            if (this.state.retryCount < MAX_RETRIES) {
              const nextRetry = this.state.retryCount + 1;
              this.setState({ retryCount: nextRetry });
              await this.speakAssistant(strings.noResponseRetry, sessionId);
              if (this.sessionId !== sessionId) return;
              return this.askQuestion(questionIndex, { preserveRetryCount: true, retryCountOverride: nextRetry });
            } else {
              await this.speakAssistant(strings.noResponseMoveOn, sessionId);
              if (this.sessionId !== sessionId) return;
              this.state.answers[question.id] = 'NO_RESPONSE';
              return this.advanceToNextQuestion(questionIndex, 'NO_RESPONSE');
            }
          }

          const genderTranscript = question.id === 'cust_id_gender'
            ? this.normalizeGenderValue(spokenAnswer)
            : null;
          const transcriptAnswer = genderTranscript
            ? this.ensureTranscriptPeriod(genderTranscript)
            : spokenAnswer;
          this.recordUserAnswer(transcriptAnswer);
          
          if (this.isRepeatRequest(spokenAnswer)) {
            const acknowledgement = strings.repeatAcknowledgement;
            this.setState({ status: 'speaking' });
            await this.speakAssistant(acknowledgement, sessionId);
            if (this.sessionId !== sessionId) return;
            return this.askQuestion(questionIndex, { preserveRetryCount: true });
          }

          if (this.isWhyRequest(spokenAnswer)) {
            return this.handleWhy(questionIndex, question, sessionId);
          }

          if (question.id === 'cust_id_gender') {
            const genderValue = this.normalizeGenderValue(spokenAnswer);
            if (genderValue) {
              this.state.answers[question.id] = genderValue;
              this.setState({ status: 'speaking' });
              this.replaceLastUserTranscript(this.ensureTranscriptPeriod(genderValue));
              await this.speakAssistant(strings.thankYou, sessionId);
              if (this.sessionId !== sessionId) return;
              return this.advanceToNextQuestion(questionIndex, genderValue);
            }
          }

          return this.handleValidation(questionIndex, question, spokenAnswer, sessionId);

      } catch (error) {
        console.error('ASR Error:', error);
        this.setState({ error: error.message, status: 'idle' });
      }
    }

      async speakAssistant(text, sessionId) {
        this.setState({ pendingAssistantMessage: text });
        await this.tts.speak(text);
        if (this.sessionId !== sessionId) return;
        const updatedTranscript = this.state.transcript.concat({ role: 'assistant', text });
        this.setState({ transcript: updatedTranscript, pendingAssistantMessage: null });
      }

      replaceLastUserTranscript(text) {
        const updatedTranscript = [...this.state.transcript];
        for (let i = updatedTranscript.length - 1; i >= 0; i -= 1) {
          if (updatedTranscript[i].role === 'user') {
            updatedTranscript[i] = { ...updatedTranscript[i], text };
            break;
          }
        }
        this.setState({ transcript: updatedTranscript });
      }

      isRepeatRequest(transcript) {
        const normalized = transcript.toLowerCase().trim();
        const patterns = [
          'repeat',
          'say that again',
          'say it again',
          'can you repeat',
          'could you repeat',
          'please repeat',
          'repeat that',
          'what was that',
          'pardon',
          'come again',
          'say again',
          'repeat please',
          'huh',
          'sorry',
          'what did you say',
          'what was the question',
          'what',
          'can you repeat that',
          'say that',
          'say it',
        ];
        if (this.state.language === 'es') {
          patterns.push(
            'repite',
            'repita',
            'repetir',
            'puede repetir',
            'podria repetir',
            'podrías repetir',
            'otra vez',
            'de nuevo',
            'que dijiste',
            'qué dijiste',
            'que fue eso',
            'qué fue eso',
            'perdon',
            'perdón',
            'disculpa',
            'disculpe',
            'repita por favor'
          );
        }
        return patterns.some((p) => normalized.includes(p));
      }

      normalizeGenderValue(text) {
        if (!text) return null;
        const trimmed = text.trim();
        const lowered = trimmed.toLowerCase().replace(/[^a-z]/g, '');
        const malePatterns = ['male', 'mail', 'man', 'm'];
        const femalePatterns = ['female', 'femail', 'woman', 'f'];
        const nonBinaryPatterns = ['nonbinary', 'nb'];
        const otherPatterns = ['other', 'prefernot', 'na'];
        if (this.state.language === 'es') {
          malePatterns.push('hombre', 'masculino', 'varon');
          femalePatterns.push('mujer', 'femenino');
          nonBinaryPatterns.push('nobinario');
          otherPatterns.push('otro');
        }
        if (malePatterns.includes(lowered)) {
          return 'Male';
        }
        if (femalePatterns.includes(lowered)) {
          return 'Female';
        }
        if (nonBinaryPatterns.includes(lowered)) {
          return 'Non-binary';
        }
        if (otherPatterns.includes(lowered)) {
          return 'Other';
        }
        return null;
      }

      ensureTranscriptPeriod(text) {
        const trimmed = text.trim();
        return trimmed.endsWith('.') ? trimmed : `${trimmed}.`;
      }

      stripAcknowledgementPrefix(text) {
        if (!text) return text;
        const trimmed = text.trim();
        const patterns = [
          /^ok\b[\s,.-]*/i,
          /^okay\b[\s,.-]*/i,
          /^alright\b[\s,.-]*/i,
          /^all right\b[\s,.-]*/i,
          /^sure\b[\s,.-]*/i,
          /^got it\b[\s,.-]*/i,
          /^i get it\b[\s,.-]*/i,
          /^i understand\b[\s,.-]*/i,
          /^that makes sense\b[\s,.-]*/i,
        ];
        if (this.state.language === 'es') {
          patterns.push(
            /^sí\b[\s,.-]*/i,
            /^si\b[\s,.-]*/i,
            /^claro\b[\s,.-]*/i,
            /^vale\b[\s,.-]*/i,
            /^de acuerdo\b[\s,.-]*/i,
            /^gracias\b[\s,.-]*/i,
            /^bueno\b[\s,.-]*/i,
            /^entiendo\b[\s,.-]*/i,
            /^tiene sentido\b[\s,.-]*/i
          );
        }

        for (const pattern of patterns) {
          if (pattern.test(trimmed)) {
            const updated = trimmed.replace(pattern, '').trim();
            return updated.length > 0 ? updated : trimmed;
          }
        }

        return trimmed;
      }

      isWhyRequest(transcript) {
        const normalized = transcript.toLowerCase().trim();
        const patterns = [
          'why do i need to answer',
          'why do i need to answer that',
          'why do i have to answer',
          'why do i have to answer that',
          'why are you asking',
          'why do you need this',
          'why do you need to know',
          'why is this needed',
          'why is that needed',
          'what is this for',
          'why is this question',
          'why do i need to',
          'why do you ask',
          'why are you asking me',
          'why are you asking that',
          'why are you asking this',
          'can you explain',
          'could you explain',
          'explain that',
          'explain this',
          'can you explain that',
          'can you explain this',
          'help me understand',
          'why',
          'explain',
        ];
        if (this.state.language === 'es') {
          patterns.push(
            'por que',
            'por qué',
            'por que pregunta',
            'por qué pregunta',
            'por que me pregunta',
            'por qué me pregunta',
            'por que necesita',
            'por qué necesita',
            'por que necesita saber',
            'por qué necesita saber',
            'para que es esto',
            'para qué es esto',
            'para que es esta pregunta',
            'para qué es esta pregunta',
            'puede explicar',
            'podria explicar',
            'podría explicar',
            'explique',
            'explica',
            'explicame',
            'explícame',
            'ayudeme a entender',
            'ayúdeme a entender'
          );
        }
        return patterns.some((p) => normalized.includes(p));
      }

      isAgentRequest(transcript) {
        const normalized = transcript.toLowerCase().trim();
        const patterns = [
          'agent',
          'representative',
          'talk to a person',
          'talk to someone',
          'speak to someone',
          'human',
          'connect me',
        ];
        if (this.state.language === 'es') {
          patterns.push(
            'agente',
            'representante',
            'hablar con una persona',
            'hablar con alguien',
            'hablar con un humano',
            'persona',
            'humano',
            'conectar'
          );
        }
        return patterns.some((p) => normalized.includes(p));
      }

      isContinueRequest(transcript) {
        const normalized = transcript.toLowerCase().trim();
        const patterns = [
          'continue',
          'keep going',
          'go on',
          'let\'s continue',
          'ready',
        ];
        if (this.state.language === 'es') {
          patterns.push(
            'continuar',
            'continua',
            'sigamos',
            'seguir',
            'sigue',
            'adelante',
            'vamos a continuar',
            'listo',
            'lista'
          );
        }
        return patterns.some((p) => normalized.includes(p));
      }

      getBridgeText(index) {
        const strings = getStrings(this.state.language);
        const options = strings.bridgeOptions;
        return options[index % options.length];
      }

      async handleWhy(questionIndex, question, sessionId) {
        const strings = getStrings(this.state.language);
        const currentCount = this.state.explainCounts[question.id] || 0;
        const nextCount = currentCount + 1;
        const explainCounts = { ...this.state.explainCounts, [question.id]: nextCount };
        this.setState({ explainCounts });

        if (nextCount > MAX_EXPLAINS) {
          return this.handleHandoff(questionIndex, question, sessionId);
        }

        this.setState({ status: 'validating' });
        const questionText = getQuestionText(question, this.state.language);
        const sectionLabel = getSectionLabel(question.section, this.state.language);
        const whyResponse = await this.why.explain(
          questionText,
          sectionLabel,
          nextCount,
          this.state.lastWhyExplanation || null,
          strings.whyFallback
        );
        if (this.sessionId !== sessionId) return;

        const explanation = whyResponse.explanation || strings.whyFallback;
        this.setState({ lastWhyExplanation: explanation });
        const bridge = this.getBridgeText(nextCount - 1);
        const prompt = strings.whyPrompt;
        const combined = `${explanation} ${bridge} ${prompt}`;

        this.setState({ status: 'speaking' });
        await this.speakAssistant(combined, sessionId);
        if (this.sessionId !== sessionId) return;

        this.setState({ status: 'listening', pendingAssistantMessage: null });
        const response = await this.asr.listen(15000);
        if (this.sessionId !== sessionId) return;

        if (!response) {
          if (this.state.retryCount < MAX_RETRIES) {
            const nextRetry = this.state.retryCount + 1;
            this.setState({ retryCount: nextRetry });
            return this.askQuestion(questionIndex, { preserveRetryCount: true, retryCountOverride: nextRetry });
          }
          return this.askQuestion(questionIndex, { preserveRetryCount: true });
        }

        this.recordUserAnswer(response);

        if (this.isRepeatRequest(response)) {
          return this.askQuestion(questionIndex, { preserveRetryCount: true });
        }

        if (this.isWhyRequest(response)) {
          return this.handleWhy(questionIndex, question, sessionId);
        }

        return this.handleValidation(questionIndex, question, response, sessionId);
      }

      async handleHandoff(questionIndex, question, sessionId) {
        const strings = getStrings(this.state.language);
        const handoffMessage = strings.handoffPrompt;
        this.setState({ status: 'speaking' });
        await this.speakAssistant(handoffMessage, sessionId);
        if (this.sessionId !== sessionId) return;

        this.setState({ status: 'listening', pendingAssistantMessage: null });
        const response = await this.asr.listen(15000);
        if (this.sessionId !== sessionId) return;

        if (!response) {
          if (this.state.retryCount < MAX_RETRIES) {
            const nextRetry = this.state.retryCount + 1;
            this.setState({ retryCount: nextRetry });
            return this.askQuestion(questionIndex, { preserveRetryCount: true, retryCountOverride: nextRetry });
          }
          return this.askQuestion(questionIndex, { preserveRetryCount: true });
        }

        this.recordUserAnswer(response);

        if (this.isAgentRequest(response)) {
          this.setState({ status: 'handoff' });
          return;
        }

        if (this.isContinueRequest(response) || this.isRepeatRequest(response)) {
          return this.askQuestion(questionIndex, { preserveRetryCount: true });
        }

        if (this.isWhyRequest(response)) {
          return this.handleHandoff(questionIndex, question, sessionId);
        }

        return this.handleValidation(questionIndex, question, response, sessionId);
      }

      async handleValidation(questionIndex, question, spokenAnswer, sessionId) {
        this.setState({ status: 'validating' });
        const strings = getStrings(this.state.language);
        const questionText = getQuestionText(question, this.state.language);
        const validation = await this.validator.validate(
          questionText,
          question.type,
          spokenAnswer,
          question.choices
        );
        if (this.sessionId !== sessionId) return;

        if (validation.repeat) {
          const acknowledgement = strings.repeatAcknowledgement;
          this.setState({ status: 'speaking' });
          await this.speakAssistant(acknowledgement, sessionId);
          if (this.sessionId !== sessionId) return;
          return this.askQuestion(questionIndex, { preserveRetryCount: true });
        }

          if (!validation.valid) {
            if (this.state.retryCount < MAX_RETRIES) {
              const retryNum = this.state.retryCount + 1;
              this.setState({ retryCount: retryNum });

            const explanation = validation.explanation || this.getGenericExplanation(question.type);
            const escalation = retryNum === 2 ? strings.retryEscalation : "";
            const clarification = explanation + escalation;

              await this.speakAssistant(clarification, sessionId);
              if (this.sessionId !== sessionId) return;
              return this.askQuestion(questionIndex, { preserveRetryCount: true, retryCountOverride: retryNum });
            }

          await this.speakAssistant(strings.moveOnNext, sessionId);
          if (this.sessionId !== sessionId) return;
          this.state.answers[question.id] = spokenAnswer;
          return this.advanceToNextQuestion(questionIndex, spokenAnswer);
        }

        const normalizedAnswer = validation.normalized;
        let cleanedAnswer = question.type === 'open'
          ? this.stripAcknowledgementPrefix(normalizedAnswer)
          : normalizedAnswer;
        if (question.id === 'cust_id_gender') {
          const genderValue = this.normalizeGenderValue(cleanedAnswer);
          if (genderValue) {
            cleanedAnswer = genderValue;
          }
        }
        this.state.answers[question.id] = cleanedAnswer;

        const followupConfig = question.followups;
        const followupWhen = followupConfig ? (followupConfig.when || 'after_valid') : null;
        const shouldRunFollowups = followupConfig && (followupWhen === 'after_valid' || followupWhen === 'after_answer');
        if (shouldRunFollowups) {
          await this.handleFollowups(question, questionIndex, cleanedAnswer, sessionId);
          if (this.sessionId !== sessionId) return;
        }

        await this.speakAssistant(strings.thankYou, sessionId);
        if (this.sessionId !== sessionId) return;

        this.advanceToNextQuestion(questionIndex, cleanedAnswer);
      }

      getGenericExplanation(questionType) {
        const strings = getStrings(this.state.language);
        const defaults = strings.genericExplanation;
        return defaults[questionType] || defaults.open;
      }

      advanceToNextQuestion(currentIndex, answer) {
        const question = QUESTIONS[currentIndex];
        let nextIndex;

        if (question.onNo && answer === 'NO') {
          nextIndex = this.handleSkipTo(question.onNo, currentIndex, this.state.answers);
        } else {
          nextIndex = this.findNextQuestionIndex(currentIndex + 1, this.state.answers);
        }

        this.askQuestion(nextIndex);
      }

      async start() {
        this.sessionId += 1;
        const sessionId = this.sessionId;
        const language = this.state.language;
        this.setState({
          status: 'speaking',
          currentQuestionIndex: -1,
          answers: {},
          transcript: [],
          retryCount: 0,
          explainCounts: {},
          lastWhyExplanation: null,
          announcementsPlayed: {},
          followups: {},
          pendingAssistantMessage: null,
          error: null,
          language,
        });

        const strings = getStrings(language);
        await this.speakAssistant(strings.introMessage, sessionId);
        if (this.sessionId !== sessionId) return;

        const firstIndex = this.findNextQuestionIndex(0, {});
        this.askQuestion(firstIndex);
      }

      stop() {
        this.sessionId += 1;
        this.tts.stop();
        this.asr.stop();
        this.setState({ status: 'idle', pendingAssistantMessage: null });
      }

      async handleFollowups(question, questionIndex, lastAnswer, sessionId) {
        const followupConfig = question.followups;
        if (!followupConfig || !followupConfig.max || followupConfig.max <= 0) {
          return;
        }

        const existing = this.state.followups[question.id] || { count: 0, items: [] };
        let count = existing.count;
        let items = [...existing.items];
        const retryLimit = Number.isInteger(followupConfig.retryLimit) ? followupConfig.retryLimit : MAX_RETRIES;
        const language = this.state.language;
        const sectionLabel = getSectionLabel(question.section, language);
        const questionText = getQuestionText(question, language);
        const resolvedIndex = Number.isInteger(questionIndex)
          ? questionIndex
          : QUESTIONS.findIndex((q) => q.id === question.id);
        const upcomingQuestions = resolvedIndex >= 0
          ? this.getUpcomingQuestionTexts(resolvedIndex, 4, language)
          : [];

        while (count < followupConfig.max) {
          const followupRequest = {
            context: language === 'es'
              ? 'Life insurance intake for underwriting risk assessment. Respond in Spanish.'
              : 'Life insurance intake for underwriting risk assessment.',
            section: sectionLabel,
            questionId: question.id,
            questionText,
            lastAnswer,
            priorAnswers: this.getRecentUserAnswers(5),
            recentQAPairs: this.getRecentQuestionAnswerPairs(4),
            sectionAnswers: this.getSectionAnswers(question.section),
            primaryContext: this.state.answers['pmv.last_visit_reason']
              ? { id: 'pmv.last_visit_reason', answer: this.state.answers['pmv.last_visit_reason'] }
              : null,
            topic: followupConfig.topic || sectionLabel,
            guidance: followupConfig.guidance || null,
            previousFollowups: this.getPreviousFollowupQuestions(question.id),
            upcomingQuestions,
          };

          const followup = await this.followup.nextQuestion(followupRequest);
          if (this.sessionId !== sessionId) return;

          if (!followup || followup.done || !followup.ask) {
            break;
          }

          const normalizedAsk = followup.ask.trim();
          if (!normalizedAsk) break;
          const askedBefore = items.some((item) => item.q.toLowerCase() === normalizedAsk.toLowerCase());
          if (askedBefore) break;
          if (this.isSimilarToUpcomingQuestion(normalizedAsk, upcomingQuestions)) break;

          const overlapCheck = await this.followup.checkOverlap({
            candidateQuestion: normalizedAsk,
            upcomingQuestions,
          });
          if (this.sessionId !== sessionId) return;
          if (!overlapCheck || overlapCheck.allow === false) break;

          this.setState({ status: 'speaking' });
          await this.speakAssistant(normalizedAsk, sessionId);
          if (this.sessionId !== sessionId) return;

          const result = await this.collectFollowupAnswer(
            normalizedAsk,
            retryLimit,
            sessionId
          );
          if (this.sessionId !== sessionId) return;

          if (!result) break;

          items = items.concat({ q: normalizedAsk, a: result.answer });
          count += 1;

          this.setState({
            followups: { ...this.state.followups, [question.id]: { count, items } },
          });
        }
      }

      async collectFollowupAnswer(questionText, retryLimit, sessionId) {
        let attempts = 0;
        let lastResponse = '';
        const strings = getStrings(this.state.language);

        while (true) {
          this.setState({ status: 'listening', pendingAssistantMessage: null });
          const response = await this.asr.listen(15000);
          if (this.sessionId !== sessionId) return null;

          if (!response) {
            if (attempts < retryLimit) {
              this.setState({ status: 'speaking' });
              await this.speakAssistant(strings.noResponseRetry, sessionId);
              if (this.sessionId !== sessionId) return null;
              await this.speakAssistant(questionText, sessionId);
              if (this.sessionId !== sessionId) return null;
              this.setState({ pendingAssistantMessage: null });
              attempts += 1;
              continue;
            }
            return { answer: 'NO_RESPONSE' };
          }

            this.recordUserAnswer(response);
          lastResponse = response;

          const validation = await this.validator.validate(
            questionText,
            'open',
            response,
            null
          );
          if (this.sessionId !== sessionId) return null;

          if (!validation.valid) {
            if (attempts < retryLimit) {
              const explanation = validation.explanation || this.getGenericExplanation('open');
              this.setState({ status: 'speaking' });
              await this.speakAssistant(explanation, sessionId);
              if (this.sessionId !== sessionId) return null;
              await this.speakAssistant(questionText, sessionId);
              if (this.sessionId !== sessionId) return null;
              this.setState({ pendingAssistantMessage: null });
              attempts += 1;
              continue;
            }
            return { answer: lastResponse };
          }

          return { answer: validation.normalized };
        }
      }
    }

    // ============================================================================
    // UI RENDERER
    // ============================================================================
    
    const controller = new FlowController();

    function renderLanguageSelect(state, strings) {
      const normalized = normalizeLanguage(state.language);
      const isDisabled = state.status !== 'idle';
      const disabledClass = isDisabled ? 'opacity-60 cursor-not-allowed' : 'cursor-pointer';
      const options = Object.entries(LANGUAGE_OPTIONS)
        .map(([key, config]) => `
          <option value="${key}" ${key === normalized ? 'selected' : ''}>${config.label}</option>
        `)
        .join('');

      return `
        <label class="flex items-center gap-2 text-xs font-semibold text-[var(--brand-text-secondary)]">
          <span>${strings.languageLabel}</span>
          <select id="languageSelect"
                  class="border border-[var(--brand-border)] rounded-md bg-white px-2 py-1 text-[var(--brand-text)] ${disabledClass}"
                  ${isDisabled ? 'disabled' : ''}>
            ${options}
          </select>
        </label>
      `;
    }

    function render(state) {
      const app = document.getElementById('app');
      const question = state.currentQuestionIndex >= 0 && state.currentQuestionIndex < QUESTIONS.length
        ? QUESTIONS[state.currentQuestionIndex]
        : null;
      const strings = getStrings(state.language);
      const sectionLabel = question ? getSectionLabel(question.section, state.language) : '';
      
      const progress = state.currentQuestionIndex >= 0
        ? Math.min(100, Math.round(((state.currentQuestionIndex + 1) / QUESTIONS.length) * 100))
        : 0;

      app.innerHTML = `
        <!-- Header -->
        <header class="sticky top-0 z-10">
          <div class="bg-white border-b border-[var(--brand-border)] px-6 py-2">
            <div class="max-w-6xl mx-auto flex items-center justify-between text-[var(--brand-primary)] text-sm font-semibold">
              <span>Protective Life</span>
              <div class="flex items-center gap-4">
                <span>${strings.headerSubtitle}</span>
                ${renderLanguageSelect(state, strings)}
              </div>
            </div>
          </div>
          <div class="bg-[var(--brand-primary)] px-6 py-4">
            <div class="max-w-6xl mx-auto flex items-center justify-between text-white">
              <div class="flex items-center gap-4">
                <img src="logo.svg" alt="Protective Life logo" class="h-8 w-auto" />
                <div>
                  <h1 class="text-xl font-bold">${strings.headerTitle}</h1>
                  <p class="text-sm text-white/80">${strings.headerTagline}</p>
                </div>
              </div>
              ${state.status !== 'idle' && state.status !== 'complete' && question ? `
                <div class="text-right">
                  <div class="text-sm font-semibold">${sectionLabel}</div>
                  <div class="text-xs text-white/70">${strings.questionCount(state.currentQuestionIndex + 1, QUESTIONS.length)}</div>
                </div>
              ` : ''}
            </div>
          </div>
        </header>

        <!-- Progress -->
        ${state.status !== 'idle' ? `
          <div class="bg-white px-6 py-2 border-b border-[var(--brand-border)]">
            <div class="max-w-6xl mx-auto">
              <div class="flex justify-between text-xs text-[var(--brand-text-secondary)] mb-1">
                <span>${strings.progressLabel}</span>
                <span>${progress}%</span>
              </div>
              <div class="w-full bg-gray-200 rounded-full h-1.5">
                <div class="bg-[var(--brand-primary)] h-1.5 rounded-full transition-all duration-500"
                     style="width: ${progress}%"></div>
              </div>
            </div>
          </div>
        ` : ''}

        <!-- Main -->
        <main class="max-w-6xl mx-auto px-6 py-12">
          <div class="flex gap-8">
            <div class="flex-1">
              ${state.status === 'idle' ? renderIdle(state, strings) : ''}
              ${['speaking', 'listening', 'validating'].includes(state.status) ? renderActive(state, question, strings) : ''}
              ${state.status === 'handoff' ? renderHandoff(strings) : ''}
              ${state.status === 'complete' ? renderComplete(state, strings) : ''}
            </div>
            ${['idle', 'complete', 'handoff'].includes(state.status) ? '' : renderChatFeed(state, strings)}
          </div>
        </main>
      `;

      // Event handlers
      document.getElementById('startBtn')?.addEventListener('click', () => controller.start());
      document.getElementById('endBtn')?.addEventListener('click', () => controller.stop());
      document.getElementById('languageSelect')?.addEventListener('change', (event) => {
        controller.setLanguage(event.target.value);
      });
      document.getElementById('restartBtn')?.addEventListener('click', () => {
        controller.state = { ...controller.state, status: 'idle' };
        render(controller.state);
      });

      const chatScroll = document.getElementById('chatScroll');
      if (chatScroll) {
        chatScroll.scrollTop = chatScroll.scrollHeight;
      }
    }

    function renderIdle(state, strings) {
      const isSupported = new ASRService().isSupported();

      return `
        <div class="text-center">
          <div class="mb-8">
            <div class="w-40 h-40 mx-auto bg-[var(--brand-primary)] rounded-full flex items-center justify-center mb-8 shadow-xl">
              <svg class="w-20 h-20 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" 
                      d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
              </svg>
            </div>
            <h2 class="text-3xl font-bold mb-4">${strings.readyTitle}</h2>
            <p class="text-[var(--brand-text-secondary)] mb-8 max-w-lg mx-auto leading-relaxed">
              ${strings.readyDescription}
            </p>
          </div>

          <button id="startBtn" 
                  class="px-10 py-4 bg-[var(--brand-primary)] hover:bg-[var(--brand-secondary)] 
                         rounded-full text-lg font-semibold text-white transition-all shadow-xl 
                         hover:scale-105">
            ${strings.startButton}
          </button>

          ${!isSupported ? `
            <div class="mt-6 p-4 bg-white border border-[var(--brand-border)] rounded-xl max-w-md mx-auto shadow-xl">
              <p class="text-[var(--brand-text-secondary)] text-sm">
                ${strings.unsupportedAsr}
              </p>
            </div>
          ` : ''}

          ${state.error ? `
            <div class="mt-6 p-4 bg-white border border-red-300 rounded-xl max-w-md mx-auto shadow-xl">
              <p class="text-red-600 text-sm">${state.error}</p>
            </div>
          ` : ''}

        </div>
      `;
    }

    function renderActive(state, question, strings) {
      const configs = {
        speaking: {
          color: 'bg-[var(--brand-primary)]',
          shadow: 'shadow-xl',
          label: strings.speakingLabel,
          sublabel: strings.speakingSub,
        },
        listening: {
          color: 'bg-[var(--brand-secondary)]',
          shadow: 'shadow-xl',
          label: strings.listeningLabel,
          sublabel: strings.listeningSub,
        },
        validating: {
          color: 'bg-[var(--brand-highlight)]',
          shadow: 'shadow-xl',
          label: strings.validatingLabel,
          sublabel: strings.validatingSub,
        },
      };
      
      const cfg = configs[state.status];
      const questionText = question ? getQuestionText(question, state.language) : '';

      return `
        <div class="text-center">
          <!-- Status Indicator -->
          <div class="mb-10">
            <div class="w-40 h-40 mx-auto ${cfg.color} rounded-full flex items-center justify-center mb-8 
                        ${cfg.shadow} ${state.status !== 'validating' ? 'pulse-ring' : ''}">
              ${state.status === 'speaking' ? `
                <div class="flex items-center gap-1">
                  ${[1,2,3,4,5].map(() => `<div class="w-1.5 bg-white rounded-full sound-bar"></div>`).join('')}
                </div>
              ` : state.status === 'listening' ? `
                <svg class="w-20 h-20 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" 
                        d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
                </svg>
              ` : `
                <svg class="w-16 h-16 text-white animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" 
                        d="M20 4v5h-0.582m-15.356 2A8.001 8.001 0 0119.418 9m0 0H15m-11 11v-5h0.581m0 0a8.003 8.003 0 0015.357-2m-15.357 2H9" />
                </svg>
              `}
            </div>
            <h2 class="text-2xl font-bold mb-2">${cfg.label}</h2>
            <p class="text-[var(--brand-text-secondary)]">${cfg.sublabel}</p>
          </div>

          <!-- Current Question -->
          ${question && state.showQuestionText !== false ? `
            <div class="bg-white rounded-xl p-8 mb-10 max-w-2xl mx-auto border-t-4 border-[var(--brand-primary)] shadow-xl">
              <p class="text-xl leading-relaxed">${questionText}</p>
              ${question.type === 'yes_no' ? `
                <p class="text-sm text-[var(--brand-text-secondary)] mt-4">${strings.yesNoHint}</p>
              ` : ''}
              ${question.type === 'choice' && question.choices ? `
                <p class="text-sm text-[var(--brand-text-secondary)] mt-4">${strings.optionsLabel}: ${question.choices.join(', ')}</p>
              ` : ''}
            </div>
          ` : ''}

          <!-- Retry indicator -->
          ${state.retryCount > 0 ? `
            <p class="text-[var(--brand-text-secondary)] text-sm mb-6">${strings.retryLabel(state.retryCount + 1, MAX_RETRIES + 1)}</p>
          ` : ''}

          <!-- End Call Button -->
          <button id="endBtn" 
                  class="px-8 py-3 bg-white text-red-600 border border-red-300 hover:border-red-400 rounded-full font-semibold transition-colors shadow-sm">
            ${strings.endCallButton}
          </button>
        </div>
      `;
    }

    function renderComplete(state, strings) {
      const summaryItems = Object.entries(state.answers).map(([id, answer]) => {
        const q = QUESTIONS.find(q => q.id === id);
        const followupItems = state.followups?.[id]?.items || [];
        const followupHtml = followupItems.length > 0
          ? `
            <div class="mt-3 space-y-2">
              ${followupItems.map((item, index) => `
                <div class="text-xs text-[var(--brand-text-secondary)]">
                  <div class="font-semibold">${strings.followupLabel(index + 1)}</div>
                  <div>${item.q}</div>
                  <div class="text-[var(--brand-text)]">${item.a}</div>
                </div>
              `).join('')}
            </div>
          `
          : '';
        return `
          <div class="flex justify-between py-3 border-b border-gray-200 last:border-0">
            <span class="text-[var(--brand-text-secondary)] text-sm flex-1 pr-4">
              ${q ? getQuestionText(q, state.language) : id}
              ${followupHtml}
            </span>
            <span class="font-medium text-sm text-right max-w-[200px]">${answer}</span>
          </div>
        `;
      }).join('');

      return `
        <div class="text-center">
          <div class="w-32 h-32 mx-auto bg-[var(--brand-primary)] rounded-full 
                      flex items-center justify-center mb-8 shadow-xl">
            <svg class="w-16 h-16 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
            </svg>
          </div>
          <h2 class="text-3xl font-bold mb-4">${strings.completionTitle}</h2>
          <p class="text-[var(--brand-text-secondary)] mb-10 max-w-lg mx-auto">
            ${strings.completionDescription}
          </p>

          <!-- Summary -->
          <div class="bg-white rounded-xl p-6 max-w-2xl mx-auto text-left border-t-4 border-[var(--brand-primary)] shadow-xl">
            <h3 class="font-semibold mb-4 text-lg">${strings.summaryTitle}</h3>
            <div class="max-h-96 overflow-y-auto">
              ${summaryItems || `<p class="text-[var(--brand-text-secondary)]">${strings.summaryEmpty}</p>`}
            </div>
          </div>

          <button id="restartBtn" 
                  class="mt-10 px-8 py-3 bg-[var(--brand-primary)] hover:bg-[var(--brand-secondary)] 
                         text-white rounded-full font-semibold transition-all shadow-xl">
            ${strings.restartButton}
          </button>
        </div>
      `;
    }

    function renderHandoff(strings) {
      return `
        <div class="text-center">
          <div class="w-32 h-32 mx-auto bg-[var(--brand-primary)] rounded-full 
                      flex items-center justify-center mb-8 shadow-xl">
            <svg class="w-16 h-16 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          </div>
          <h2 class="text-3xl font-bold mb-4">${strings.handoffTitle}</h2>
          <p class="text-[var(--brand-text-secondary)] mb-10 max-w-lg mx-auto">
            ${strings.handoffDescription}
          </p>
          <button id="restartBtn" 
                  class="mt-4 px-8 py-3 bg-[var(--brand-primary)] hover:bg-[var(--brand-secondary)] 
                         text-white rounded-full font-semibold transition-all shadow-xl">
            ${strings.handoffRestartButton}
          </button>
        </div>
      `;
    }

    function renderTranscript(state, strings) {
      const transcriptHtml = state.transcript.map(entry => `
        <div class="py-2 ${entry.role === 'user' ? 'text-blue-400' : 'text-slate-300'}">
          <span class="font-semibold text-xs uppercase tracking-wide opacity-60">
            ${entry.role === 'user' ? strings.transcriptUser : strings.transcriptSystem}:
          </span>
          <span class="ml-2">${entry.text}</span>
        </div>
      `).join('');

      return `
        <div class="fixed bottom-4 right-4 z-50">
          <details class="bg-slate-900/95 backdrop-blur rounded-lg border border-slate-700 shadow-xl max-w-md">
            <summary class="px-4 py-2 cursor-pointer text-slate-400 hover:text-white text-sm">
              ${strings.transcriptLabel(state.transcript.length)}
            </summary>
            <div class="px-4 pb-4 max-h-64 overflow-y-auto text-sm">
              ${transcriptHtml}
            </div>
          </details>
        </div>
      `;
    }

    function renderChatFeed(state, strings) {
      const bubbleHtml = state.transcript.map(entry => {
        const isUser = entry.role === 'user';
        const bubbleClass = isUser
          ? 'bg-[var(--brand-primary)] text-white rounded-2xl rounded-br-sm'
          : 'bg-gray-200 text-[var(--brand-text)] rounded-2xl rounded-bl-sm';
        const alignClass = isUser ? 'justify-end' : 'justify-start';

        return `
          <div class="flex ${alignClass}">
            <div class="max-w-[220px] px-4 py-2 text-sm leading-relaxed ${bubbleClass}">
              ${entry.text}
            </div>
          </div>
        `;
      }).join('');

      const showUserTyping = state.status === 'listening' && state.transcript.length > 0;
      const showSystemTyping = state.status === 'validating' && state.transcript.length > 0;

      const typingDots = (alignRight) => `
        <div class="flex ${alignRight ? 'justify-end' : 'justify-start'}">
          <div class="flex items-center gap-1 px-4 py-2 rounded-2xl ${alignRight ? 'bg-[var(--brand-primary)]' : 'bg-gray-200'}">
            <span class="w-1.5 h-1.5 rounded-full ${alignRight ? 'bg-white/80' : 'bg-[var(--brand-text-secondary)]'} animate-bounce [animation-delay:-0.2s]"></span>
            <span class="w-1.5 h-1.5 rounded-full ${alignRight ? 'bg-white/80' : 'bg-[var(--brand-text-secondary)]'} animate-bounce [animation-delay:-0.1s]"></span>
            <span class="w-1.5 h-1.5 rounded-full ${alignRight ? 'bg-white/80' : 'bg-[var(--brand-text-secondary)]'} animate-bounce"></span>
          </div>
        </div>
      `;

      return `
        <aside class="w-80 shrink-0">
          <div class="bg-white border-t-4 border-[var(--brand-primary)] rounded-3xl p-4 shadow-xl h-[520px] flex flex-col">
            <div class="flex items-center gap-3 pb-4 border-b border-gray-200">
              <div class="w-10 h-10 rounded-full bg-[var(--brand-primary)] flex items-center justify-center">
                <span class="text-sm font-semibold text-white">AI</span>
              </div>
              <div>
                <div class="text-sm font-semibold">${strings.chatAssistantName}</div>
                <div class="text-xs text-[var(--brand-text-secondary)]">${strings.chatSubtitle}</div>
              </div>
            </div>
            <div id="chatScroll" class="flex-1 overflow-y-auto space-y-3 py-4 pr-1">
              ${bubbleHtml || `<div class="text-[var(--brand-text-secondary)] text-sm">${strings.chatEmpty}</div>`}
              ${showUserTyping ? typingDots(true) : ''}
              ${state.pendingAssistantMessage ? typingDots(false) : ''}
              ${showSystemTyping && !state.pendingAssistantMessage && state.status !== 'listening' ? typingDots(false) : ''}
            </div>
            <div class="pt-3 border-t border-gray-200">
              <div class="bg-[var(--brand-background)] rounded-xl px-4 py-3 text-[var(--brand-text-secondary)] text-xs">
                ${strings.voiceModeEnabled}
              </div>
            </div>
          </div>
        </aside>
      `;
    }

    // Initialize
    async function init() {
      await loadConfig();
      controller.onStateChange = render;
      render(controller.state);
    }

    init();
  </script>
</body>
</html>
